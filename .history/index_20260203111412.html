<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>基本情報技術者試験 科目B 模擬試験（20問・40分）</title>
    <style>
        :root {
            --bg: #0b0f14;
            --panel: #111824;
            --panel2: #0f1620;
            --text: #e8eef7;
            --muted: #a9b6c7;
            --accent: #6aa8ff;
            --ok: #35d07f;
            --ng: #ff5d5d;
            --border: rgba(255, 255, 255, .10);
            --shadow: 0 10px 30px rgba(0, 0, 0, .35);
            --radius: 14px;
            --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            --sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Sans", "Yu Gothic", "Meiryo", sans-serif;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: var(--sans);
            background: radial-gradient(1200px 700px at 20% 10%, rgba(106, 168, 255, .16), transparent 55%),
                radial-gradient(900px 650px at 70% 10%, rgba(53, 208, 127, .10), transparent 55%),
                var(--bg);
            color: var(--text);
        }

        .wrap {
            max-width: 1100px;
            margin: 0 auto;
            padding: 18px 14px 40px;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 14px;
        }

        @media (max-width: 980px) {
            .wrap {
                grid-template-columns: 1fr;
            }

            .side {
                order: 2;
            }

            .main {
                order: 1;
            }
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, .04), rgba(255, 255, 255, .02));
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .card .hd {
            padding: 14px 14px 12px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: rgba(255, 255, 255, .02);
        }

        .title {
            font-weight: 700;
            letter-spacing: .2px;
        }

        .muted {
            color: var(--muted);
        }

        .pill {
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--muted);
            background: rgba(0, 0, 0, .18);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn {
            appearance: none;
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, .18);
            color: var(--text);
            border-radius: 12px;
            padding: 10px 12px;
            font-weight: 650;
            cursor: pointer;
            transition: transform .02s ease, border-color .2s ease, background .2s ease;
            user-select: none;
        }

        .btn:hover {
            border-color: rgba(106, 168, 255, .45);
            background: rgba(106, 168, 255, .12);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn.primary {
            border-color: rgba(106, 168, 255, .55);
            background: rgba(106, 168, 255, .18);
        }

        .btn.danger {
            border-color: rgba(255, 93, 93, .45);
            background: rgba(255, 93, 93, .10);
        }

        .btn:disabled {
            opacity: .45;
            cursor: not-allowed;
        }

        .side .bd {
            padding: 12px 12px 14px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .qbtn {
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, .18);
            color: var(--text);
            border-radius: 12px;
            padding: 10px 0;
            font-weight: 700;
            cursor: pointer;
            position: relative;
        }

        .qbtn:hover {
            border-color: rgba(106, 168, 255, .45);
            background: rgba(106, 168, 255, .10);
        }

        .qbtn.active {
            outline: 2px solid rgba(106, 168, 255, .70);
            outline-offset: 1px;
        }

        .qbtn.answered {
            border-color: rgba(53, 208, 127, .45);
        }

        .qbtn.flagged::after {
            content: "⚑";
            position: absolute;
            top: 6px;
            right: 8px;
            font-size: 12px;
            color: rgba(255, 255, 255, .85);
            opacity: .9;
        }

        .qbtn.review-ok {
            border-color: rgba(53, 208, 127, .65);
            background: rgba(53, 208, 127, .08);
        }

        .qbtn.review-ng {
            border-color: rgba(255, 93, 93, .65);
            background: rgba(255, 93, 93, .08);
        }

        .main .bd {
            padding: 16px 16px 18px;
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .code {
            font-family: var(--mono);
            background: rgba(0, 0, 0, .28);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            overflow-x: auto;
            color: #d9e6ff;
            line-height: 1.45;
            margin: 10px 0 12px;
            white-space: pre;
        }

        .qtext {
            font-size: 16px;
            line-height: 1.6;
            margin: 10px 0 12px;
        }

        .opts {
            display: grid;
            gap: 10px;
        }

        .opt {
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, .18);
            border-radius: 14px;
            padding: 12px 12px;
            display: flex;
            gap: 10px;
            align-items: flex-start;
            cursor: pointer;
        }

        .opt:hover {
            border-color: rgba(106, 168, 255, .45);
            background: rgba(106, 168, 255, .10);
        }

        .opt input {
            margin-top: 2px;
        }

        .opt .lab {
            flex: 1;
            line-height: 1.5;
        }

        .opt.selected {
            outline: 2px solid rgba(106, 168, 255, .70);
            outline-offset: 1px;
        }

        .opt.correct {
            border-color: rgba(53, 208, 127, .65);
            background: rgba(53, 208, 127, .08);
        }

        .opt.wrong {
            border-color: rgba(255, 93, 93, .65);
            background: rgba(255, 93, 93, .08);
        }

        .hr {
            height: 1px;
            background: var(--border);
            margin: 14px 0;
        }

        .explain {
            margin-top: 12px;
            border-left: 4px solid rgba(106, 168, 255, .55);
            padding: 10px 12px;
            background: rgba(106, 168, 255, .08);
            border-radius: 12px;
            display: none;
            line-height: 1.65;
            color: #dfeaff;
        }

        .explain.show {
            display: block;
        }

        .badge {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, .18);
            font-size: 12px;
            color: var(--muted);
        }

        .badge.ok {
            border-color: rgba(53, 208, 127, .55);
            color: rgba(53, 208, 127, .95);
            background: rgba(53, 208, 127, .10);
        }

        .badge.ng {
            border-color: rgba(255, 93, 93, .55);
            color: rgba(255, 93, 93, .95);
            background: rgba(255, 93, 93, .10);
        }

        dialog {
            width: min(720px, calc(100% - 24px));
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: rgba(17, 24, 36, .97);
            color: var(--text);
            box-shadow: var(--shadow);
            padding: 0;
        }

        dialog::backdrop {
            background: rgba(0, 0, 0, .55);
        }

        .dlg-hd {
            padding: 14px 14px 12px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            gap: 12px;
            align-items: center;
        }

        .dlg-bd {
            padding: 14px;
        }

        .dlg-ft {
            padding: 12px 14px 14px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            flex-wrap: wrap;
        }

        .kpi {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <!-- Sidebar -->
        <aside class="side card">
            <div class="hd">
                <div>
                    <div class="title">科目B 模擬試験</div>
                    <div class="muted" style="font-size:12px; margin-top:2px;">20問・40分想定（CBT練習）</div>
                </div>
                <div class="pill" id="timerPill">⏱ <span id="timer">40:00</span></div>
            </div>
            <div class="bd">
                <div class="row" style="justify-content: space-between;">
                    <span class="badge" id="progressBadge">進捗: 0 / 20</span>
                    <span class="badge" id="flagBadge">旗: 0</span>
                </div>

                <div class="grid" id="grid"></div>

                <div class="hr"></div>

                <div class="row" style="justify-content: space-between;">
                    <button class="btn" id="toggleFlagBtn">旗を付ける</button>
                    <button class="btn" id="clearBtn" title="この問題の選択を消します">選択解除</button>
                </div>

                <div class="row" style="margin-top:10px;">
                    <button class="btn" id="saveBtn" title="localStorageに保存">保存</button>
                    <button class="btn" id="loadBtn" title="localStorageから復元">復元</button>
                    <button class="btn danger" id="resetBtn" title="全データを消去">リセット</button>
                </div>

                <div class="hr"></div>

                <div class="row">
                    <button class="btn primary" id="submitBtn">提出して採点</button>
                </div>

                <div class="muted" style="font-size:12px; margin-top:10px; line-height:1.6;">
                    ・提出前：解説は表示されません<br>
                    ・提出後：正誤と解説を表示します<br>
                    ・保存/復元はこのブラウザ内のみ有効です
                </div>
            </div>
        </aside>

        <!-- Main -->
        <main class="main card">
            <div class="hd">
                <div class="row">
                    <span class="pill">問題 <b id="qNo">1</b> / 20</span>
                    <span class="pill" id="groupPill">共通擬似言語①</span>
                    <span class="pill" id="statusPill">未回答</span>
                </div>
                <div class="row">
                    <button class="btn" id="prevBtn">前へ</button>
                    <button class="btn" id="nextBtn">次へ</button>
                </div>
            </div>

            <div class="bd">
                <div id="stem"></div>
                <div id="codeBlock" class="code" style="display:none;"></div>

                <div class="qtext" id="qText"></div>

                <div class="opts" id="opts"></div>

                <div class="explain" id="explain"></div>

                <div class="hr"></div>

                <div class="row" style="justify-content: space-between;">
                    <div class="muted" style="font-size:12px;">
                        ショートカット：<b>1</b>〜<b>4</b>で選択／<b>←</b><b>→</b>で移動
                    </div>
                    <div class="row">
                        <button class="btn" id="jumpFirst">最初へ</button>
                        <button class="btn" id="jumpLast">最後へ</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <dialog id="resultDlg">
        <div class="dlg-hd">
            <div class="title">採点結果</div>
            <button class="btn" id="closeDlg">閉じる</button>
        </div>
        <div class="dlg-bd">
            <div class="kpi">
                <span class="badge ok" id="scoreBadge">得点: 0 / 20</span>
                <span class="badge" id="answeredBadge">回答: 0 / 20</span>
                <span class="badge" id="timeBadge">残り時間: --:--</span>
            </div>
            <div class="hr"></div>
            <div class="muted" style="line-height:1.7;">
                提出後は、各問題で「正解（緑）／不正解（赤）」が表示され、解説が見られます。<br>
                旗を付けた問題や間違えた問題を中心に復習してください。
            </div>
        </div>
        <div class="dlg-ft">
            <button class="btn" id="reviewWrong">不正解へ移動</button>
            <button class="btn primary" id="reviewFlagged">旗の問題へ移動</button>
            <button class="btn danger" id="lockBtn" title="採点後に回答を固定します（解除不可）">採点状態を固定</button>
        </div>
    </dialog>

    <script>
        // ========= Question Data =========
        const code1 = `A ← [ 7, 3, 9, 4, 6 ]
N ← LENGTH(A)

for last ← N downto 2
  MAX ← A[1]
  MAX_POS ← 1

  for i ← 2 to last
    if A[i] > MAX then
      MAX ← A[i]
      MAX_POS ← i
    endif
  endfor

  TEMP ← A[last]
  A[last] ← A[MAX_POS]
  A[MAX_POS] ← TEMP
endfor`;

        const code2 = `A ← [ 4, 6, 2, 5, 1 ]
N ← LENGTH(A)

i ← 1
while i < N
  if A[i] > A[i+1] then
    TEMP ← A[i]
    A[i] ← A[i+1]
    A[i+1] ← TEMP
  endif
  i ← i + 1
endwhile`;

        // option format: {k:"ア", t:"...."}
        const questions = [
            // 1-10 selection-sort style
            {
                group: "共通擬似言語①",
                stem: "次の擬似言語は，配列 A の要素を昇順に並べ替える処理である。",
                code: code1,
                text: "外側ループ1回目終了後に確定している要素はどれか。",
                options: [
                    { k: "ア", t: "7" },
                    { k: "イ", t: "3" },
                    { k: "ウ", t: "9" },
                    { k: "エ", t: "4" },
                ],
                answer: "ウ",
                explain: "外側ループ1回目では探索範囲 A[1]～A[5] の最大値 9 が末尾に移動し確定する。"
            },
            {
                group: "共通擬似言語①",
                stem: "上の擬似言語に関する設問である。",
                code: code1,
                text: "外側ループ2回目終了後，確定している要素の個数はどれか。",
                options: [
                    { k: "ア", t: "1" },
                    { k: "イ", t: "2" },
                    { k: "ウ", t: "3" },
                    { k: "エ", t: "4" },
                ],
                answer: "イ",
                explain: "1回目で 9，2回目で 7 が末尾側に確定するため，確定要素は2個。"
            },
            {
                group: "共通擬似言語①",
                stem: "上の擬似言語に関する設問である。",
                code: code1,
                text: "外側ループ3回目（last=3）で行われる比較回数はどれか。",
                options: [
                    { k: "ア", t: "0" },
                    { k: "イ", t: "1" },
                    { k: "ウ", t: "2" },
                    { k: "エ", t: "3" },
                ],
                answer: "ウ",
                explain: "内側ループは i=2～last。last=3 なので i=2,3 の2回比較する。"
            },
            {
                group: "共通擬似言語①",
                stem: "上の擬似言語に関する設問である。",
                code: code1,
                text: "MAX の初期化が「MAX ← A[1]」である理由として最も適切なものはどれか。",
                options: [
                    { k: "ア", t: "先頭要素が最大と仮定して探索を開始するため" },
                    { k: "イ", t: "添字1が常に最大だから" },
                    { k: "ウ", t: "A[0]が存在しないから" },
                    { k: "エ", t: "交換回数を減らすため" },
                ],
                answer: "ア",
                explain: "最大値探索では暫定の最大値を1つ置いて更新していく。先頭要素を暫定最大として開始するのが自然。"
            },
            {
                group: "共通擬似言語①",
                stem: "上の擬似言語に関する設問である。",
                code: code1,
                text: "外側ループのある回で，配列の内容が変化しないのはどの場合か。",
                options: [
                    { k: "ア", t: "MAX が更新されなかった場合" },
                    { k: "イ", t: "MAX_POS = last の場合" },
                    { k: "ウ", t: "MAX < A[last] の場合" },
                    { k: "エ", t: "i が last に達しない場合" },
                ],
                answer: "イ",
                explain: "最大値がすでに A[last] にあると MAX_POS=last となり，同一要素同士の交換になるため配列は変化しない。"
            },
            {
                group: "共通擬似言語①",
                stem: "上の擬似言語に関する設問である。",
                code: code1,
                text: "内側ループで A[1] が比較されない理由として正しいものはどれか。",
                options: [
                    { k: "ア", t: "すでに確定済みだから" },
                    { k: "イ", t: "MAX の初期値として使われるから" },
                    { k: "ウ", t: "for文が1始まりだから" },
                    { k: "エ", t: "意味がないから" },
                ],
                answer: "イ",
                explain: "比較は i=2 から始まるため A[i] として A[1] は出てこないが，MAX の初期値として A[1] は利用される。"
            },
            {
                group: "共通擬似言語①",
                stem: "上の擬似言語に関する設問である。",
                code: code1,
                text: "全体の比較回数の合計として正しい式はどれか。",
                options: [
                    { k: "ア", t: "(N−1)+(N−2)+…+2" },
                    { k: "イ", t: "(N−1)+(N−2)+…+1" },
                    { k: "ウ", t: "N(N−1)/2" },
                    { k: "エ", t: "N²" },
                ],
                answer: "イ",
                explain: "各回の比較回数は last=Nで(N−1)，…，last=2で1回。last=2のときも i=2 to 2 が1回実行されるため，最後の「+1」が必要。"
            },
            {
                group: "共通擬似言語①",
                stem: "上の擬似言語に関する設問である。",
                code: code1,
                text: "この処理が安定ソートでない理由として正しいものはどれか。",
                options: [
                    { k: "ア", t: "最大値を探索するから" },
                    { k: "イ", t: "同じ値の相対順序が保持されないから" },
                    { k: "ウ", t: "2重ループだから" },
                    { k: "エ", t: "交換処理があるから" },
                ],
                answer: "イ",
                explain: "選択型の交換では，同値要素の相対順序が入れ替わる可能性があるため安定ではない。"
            },
            {
                group: "共通擬似言語①",
                stem: "上の擬似言語に関する設問である。",
                code: code1,
                text: "この処理とバブルソートの最大の違いはどれか。",
                options: [
                    { k: "ア", t: "使用する変数" },
                    { k: "イ", t: "比較対象の範囲" },
                    { k: "ウ", t: "交換回数" },
                    { k: "エ", t: "配列の長さ" },
                ],
                answer: "イ",
                explain: "バブルソートは隣接要素同士の比較を繰り返す。ここでは探索範囲全体から最大値を探して末尾へ移動する。"
            },
            {
                group: "共通擬似言語①",
                stem: "上の擬似言語に関する設問である。",
                code: code1,
                text: "この処理の計算量（オーダ）として最も適切なものはどれか。",
                options: [
                    { k: "ア", t: "O(N)" },
                    { k: "イ", t: "O(N log N)" },
                    { k: "ウ", t: "O(N²)" },
                    { k: "エ", t: "O(2ⁿ)" },
                ],
                answer: "ウ",
                explain: "比較回数は (N−1)+(N−2)+…+1 でおおむね N²/2 に比例するため O(N²)。"
            },

            // 11-20 bubble-pass style
            {
                group: "共通擬似言語②",
                stem: "次の擬似言語は，配列 A の隣接要素を比較して必要に応じて交換する処理である。",
                code: code2,
                text: "この処理が1回実行された後，末尾に移動する可能性がある要素はどれか。",
                options: [
                    { k: "ア", t: "4" },
                    { k: "イ", t: "6" },
                    { k: "ウ", t: "2" },
                    { k: "エ", t: "1" },
                ],
                answer: "イ",
                explain: "隣接交換を左から右へ1回流すと，大きい値ほど右へ押し出され，最大値が末尾へ到達しやすい。"
            },
            {
                group: "共通擬似言語②",
                stem: "上の擬似言語に関する設問である。",
                code: code2,
                text: "この処理を1回実行した後の配列として正しいものはどれか。",
                options: [
                    { k: "ア", t: "[ 4, 2, 5, 1, 6 ]" },
                    { k: "イ", t: "[ 4, 6, 2, 1, 5 ]" },
                    { k: "ウ", t: "[ 4, 2, 6, 1, 5 ]" },
                    { k: "エ", t: "[ 4, 6, 2, 5, 1 ]" },
                ],
                answer: "ア",
                explain: "手順： (4,6)交換なし→(6,2)交換→(6,5)交換→(6,1)交換。結果は [4,2,5,1,6]。"
            },
            {
                group: "共通擬似言語②",
                stem: "上の擬似言語に関する設問である。",
                code: code2,
                text: "この処理を N−1 回繰り返すと完成するソートはどれか。",
                options: [
                    { k: "ア", t: "選択ソート" },
                    { k: "イ", t: "クイックソート" },
                    { k: "ウ", t: "バブルソート" },
                    { k: "エ", t: "マージソート" },
                ],
                answer: "ウ",
                explain: "隣接比較と交換を繰り返し，最大値が末尾へ“泡上がり”していくのがバブルソート。"
            },
            {
                group: "共通擬似言語②",
                stem: "上の擬似言語に関する設問である。",
                code: code2,
                text: "while 条件が「i ≤ N」だった場合に起こる問題はどれか。",
                options: [
                    { k: "ア", t: "無限ループ" },
                    { k: "イ", t: "添字範囲外参照" },
                    { k: "ウ", t: "比較回数不足" },
                    { k: "エ", t: "交換が起きない" },
                ],
                answer: "イ",
                explain: "i=N でもループに入ると A[i+1]=A[N+1] を参照してしまい範囲外。"
            },
            {
                group: "共通擬似言語②",
                stem: "上の擬似言語に関する設問である。",
                code: code2,
                text: "この処理が安定ソートである理由として正しいものはどれか。",
                options: [
                    { k: "ア", t: "隣接要素のみを交換するから" },
                    { k: "イ", t: "最大値を探索しないから" },
                    { k: "ウ", t: "ループ回数が一定だから" },
                    { k: "エ", t: "一時変数を使うから" },
                ],
                answer: "ア",
                explain: "通常のバブルソートは「>」で比較し，同値なら交換しないため，同じ値の相対順序が保たれやすい（安定）。"
            },
            {
                group: "共通擬似言語②",
                stem: "上の擬似言語に関する設問である。",
                code: code2,
                text: "この処理1回あたりの比較回数はどれか。",
                options: [
                    { k: "ア", t: "N" },
                    { k: "イ", t: "N−1" },
                    { k: "ウ", t: "N−2" },
                    { k: "エ", t: "1" },
                ],
                answer: "イ",
                explain: "i=1～N−1 の各回で A[i] と A[i+1] を比較するため N−1 回。"
            },
            {
                group: "共通擬似言語②",
                stem: "上の擬似言語を N−1 回繰り返したときの性質を考える。",
                code: code2,
                text: "この処理の計算量として正しいものはどれか。",
                options: [
                    { k: "ア", t: "O(N)" },
                    { k: "イ", t: "O(N log N)" },
                    { k: "ウ", t: "O(N²)" },
                    { k: "エ", t: "O(log N)" },
                ],
                answer: "ウ",
                explain: "1回あたり O(N) を N−1 回繰り返すため O(N²)。"
            },
            {
                group: "共通擬似言語②",
                stem: "上の擬似言語に関する設問である。",
                code: code2,
                text: "if 文の条件を「A[i] >= A[i+1]」に変更した場合の影響として正しいものはどれか。",
                options: [
                    { k: "ア", t: "正しく整列しなくなる" },
                    { k: "イ", t: "安定性が失われる" },
                    { k: "ウ", t: "比較回数が増える" },
                    { k: "エ", t: "処理が高速化する" },
                ],
                answer: "イ",
                explain: "同値でも交換してしまうため，同じ値の相対順序が入れ替わり得て安定性が失われる。"
            },
            {
                group: "共通擬似言語②",
                stem: "上の擬似言語に関する設問である。",
                code: code2,
                text: "この処理で比較されない要素の組はどれか。",
                options: [
                    { k: "ア", t: "A[1] と A[2]" },
                    { k: "イ", t: "A[2] と A[3]" },
                    { k: "ウ", t: "A[3] と A[4]" },
                    { k: "エ", t: "A[1] と A[5]" },
                ],
                answer: "エ",
                explain: "比較は常に隣接要素（i と i+1）。A[1] と A[5] は隣接しないため比較されない。"
            },
            {
                group: "共通擬似言語①・②",
                stem: "問1〜10（最大値を末尾に確定）と，問11〜19（隣接比較）を比較する。",
                code: "",
                text: "両者の本質的な違いとして最も適切なものはどれか。",
                options: [
                    { k: "ア", t: "使用する変数" },
                    { k: "イ", t: "ソート対象" },
                    { k: "ウ", t: "比較方法" },
                    { k: "エ", t: "ループ構造" },
                ],
                answer: "ウ",
                explain: "前半は探索範囲全体から最大値を探す（全体比較型）。後半は隣接要素を比較する（隣接比較型）。"
            },
        ];

        // ========= State =========
        const LS_KEY = "fe_b_mock_cbt_v1";
        let idx = 0;
        let submitted = false;
        let locked = false;
        let remainingSec = 40 * 60;
        let timerId = null;

        const state = {
            answers: Array(questions.length).fill(null), // "ア".."エ"
            flagged: Array(questions.length).fill(false),
        };

        // ========= Elements =========
        const elGrid = document.getElementById("grid");
        const elTimer = document.getElementById("timer");
        const elProgress = document.getElementById("progressBadge");
        const elFlagBadge = document.getElementById("flagBadge");
        const elQNo = document.getElementById("qNo");
        const elGroup = document.getElementById("groupPill");
        const elStatus = document.getElementById("statusPill");
        const elStem = document.getElementById("stem");
        const elCode = document.getElementById("codeBlock");
        const elQText = document.getElementById("qText");
        const elOpts = document.getElementById("opts");
        const elExplain = document.getElementById("explain");

        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");
        const toggleFlagBtn = document.getElementById("toggleFlagBtn");
        const clearBtn = document.getElementById("clearBtn");
        const saveBtn = document.getElementById("saveBtn");
        const loadBtn = document.getElementById("loadBtn");
        const resetBtn = document.getElementById("resetBtn");
        const submitBtn = document.getElementById("submitBtn");
        const jumpFirst = document.getElementById("jumpFirst");
        const jumpLast = document.getElementById("jumpLast");

        // result dialog
        const dlg = document.getElementById("resultDlg");
        const closeDlg = document.getElementById("closeDlg");
        const scoreBadge = document.getElementById("scoreBadge");
        const answeredBadge = document.getElementById("answeredBadge");
        const timeBadge = document.getElementById("timeBadge");
        const reviewWrong = document.getElementById("reviewWrong");
        const reviewFlagged = document.getElementById("reviewFlagged");
        const lockBtn = document.getElementById("lockBtn");

        // ========= Helpers =========
        const fmt = (sec) => {
            const m = Math.floor(sec / 60);
            const s = sec % 60;
            return String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
        };
        const answeredCount = () => state.answers.filter(v => v !== null).length;
        const flaggedCount = () => state.flagged.filter(Boolean).length;

        function calcScore() {
            let score = 0;
            for (let i = 0; i < questions.length; i++) {
                if (state.answers[i] && state.answers[i] === questions[i].answer) score++;
            }
            return score;
        }

        function buildGrid() {
            elGrid.innerHTML = "";
            for (let i = 0; i < questions.length; i++) {
                const b = document.createElement("button");
                b.className = "qbtn";
                b.textContent = (i + 1);
                b.addEventListener("click", () => go(i));
                elGrid.appendChild(b);
            }
        }

        function updateGridStyles() {
            const btns = [...elGrid.querySelectorAll(".qbtn")];
            btns.forEach((b, i) => {
                b.classList.toggle("active", i === idx);
                b.classList.toggle("answered", state.answers[i] !== null);
                b.classList.toggle("flagged", state.flagged[i]);

                b.classList.remove("review-ok", "review-ng");
                if (submitted) {
                    const ok = state.answers[i] !== null && state.answers[i] === questions[i].answer;
                    const ng = state.answers[i] !== null && state.answers[i] !== questions[i].answer;
                    if (ok) b.classList.add("review-ok");
                    if (ng) b.classList.add("review-ng");
                }
            });
        }

        function updateBadges() {
            elProgress.textContent = `進捗: ${answeredCount()} / ${questions.length}`;
            elFlagBadge.textContent = `旗: ${flaggedCount()}`;
        }

        function render() {
            const q = questions[idx];
            elQNo.textContent = String(idx + 1);
            elGroup.textContent = q.group;
            elStem.innerHTML = `<div class="muted" style="font-size:12px;">${escapeHtml(q.stem)}</div>`;

            if (q.code && q.code.trim().length > 0) {
                elCode.style.display = "block";
                elCode.textContent = q.code;
            } else {
                elCode.style.display = "none";
                elCode.textContent = "";
            }

            elQText.textContent = q.text;

            const ans = state.answers[idx];
            elStatus.textContent = ans ? `選択中：${ans}` : "未回答";
            elStatus.style.borderColor = ans ? "rgba(53,208,127,.55)" : "rgba(255,255,255,.10)";
            elStatus.style.background = ans ? "rgba(53,208,127,.10)" : "rgba(0,0,0,.18)";
            elStatus.style.color = ans ? "rgba(53,208,127,.95)" : "var(--muted)";

            // options
            elOpts.innerHTML = "";
            q.options.forEach((op) => {
                const wrap = document.createElement("label");
                wrap.className = "opt";
                const radio = document.createElement("input");
                radio.type = "radio";
                radio.name = "opt";
                radio.value = op.k;
                radio.checked = (ans === op.k);
                radio.disabled = locked || (submitted && locked);

                const lab = document.createElement("div");
                lab.className = "lab";
                lab.innerHTML = `<b>${op.k}</b>　${escapeHtml(op.t)}`;

                wrap.appendChild(radio);
                wrap.appendChild(lab);

                if (ans === op.k) wrap.classList.add("selected");

                wrap.addEventListener("click", (e) => {
                    if (locked) { e.preventDefault(); return; }
                    if (submitted && locked) { e.preventDefault(); return; }
                    choose(op.k);
                });

                elOpts.appendChild(wrap);
            });

            // explanation & review styling
            elExplain.classList.remove("show");
            elExplain.innerHTML = "";
            if (submitted) {
                const picked = state.answers[idx];
                const correct = q.answer;

                // style options
                [...elOpts.children].forEach((node) => {
                    const val = node.querySelector("input")?.value;
                    node.classList.remove("correct", "wrong");
                    if (val === correct) node.classList.add("correct");
                    if (picked && val === picked && picked !== correct) node.classList.add("wrong");
                });

                const ok = picked && picked === correct;
                const ng = picked && picked !== correct;
                const badge = ok
                    ? `<span class="badge ok">正解</span>`
                    : (ng ? `<span class="badge ng">不正解</span>` : `<span class="badge ng">未回答</span>`);

                elExplain.innerHTML = `${badge}　正解：<b>${correct}</b><br>${escapeHtml(q.explain)}`;
                elExplain.classList.add("show");
            }

            prevBtn.disabled = (idx === 0);
            nextBtn.disabled = (idx === questions.length - 1);

            toggleFlagBtn.textContent = state.flagged[idx] ? "旗を外す" : "旗を付ける";
            toggleFlagBtn.disabled = false;

            clearBtn.disabled = (state.answers[idx] === null) || locked;

            submitBtn.disabled = submitted; // one-time submit (can still review)
            updateBadges();
            updateGridStyles();
        }

        function choose(k) {
            state.answers[idx] = k;
            render();
        }

        function clearAnswer() {
            state.answers[idx] = null;
            render();
        }

        function toggleFlag() {
            state.flagged[idx] = !state.flagged[idx];
            render();
        }

        function go(i) {
            idx = Math.max(0, Math.min(questions.length - 1, i));
            render();
        }

        function next() { if (idx < questions.length - 1) go(idx + 1); }
        function prev() { if (idx > 0) go(idx - 1); }

        function escapeHtml(s) {
            return String(s)
                .replaceAll("&", "&amp;")
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;")
                .replaceAll('"', "&quot;")
                .replaceAll("'", "&#039;");
        }

        // ========= Timer =========
        function startTimer() {
            if (timerId) return;
            timerId = setInterval(() => {
                if (remainingSec > 0) remainingSec--;
                elTimer.textContent = fmt(remainingSec);
                if (remainingSec === 0) {
                    clearInterval(timerId);
                    timerId = null;
                    // auto-submit (if not submitted)
                    if (!submitted) doSubmit(true);
                }
            }, 1000);
        }

        // ========= Persistence =========
        function save() {
            const payload = {
                v: 1,
                idx,
                submitted,
                locked,
                remainingSec,
                state
            };
            localStorage.setItem(LS_KEY, JSON.stringify(payload));
            toast("保存しました");
        }

        function load() {
            const raw = localStorage.getItem(LS_KEY);
            if (!raw) { toast("保存データがありません"); return; }
            try {
                const p = JSON.parse(raw);
                if (!p || !p.state) throw new Error("bad");
                idx = p.idx ?? 0;
                submitted = !!p.submitted;
                locked = !!p.locked;
                remainingSec = typeof p.remainingSec === "number" ? p.remainingSec : remainingSec;
                state.answers = Array.isArray(p.state.answers) ? p.state.answers.slice(0, questions.length) : state.answers;
                state.flagged = Array.isArray(p.state.flagged) ? p.state.flagged.slice(0, questions.length) : state.flagged;
                // fill to length
                while (state.answers.length < questions.length) state.answers.push(null);
                while (state.flagged.length < questions.length) state.flagged.push(false);
                elTimer.textContent = fmt(remainingSec);
                render();
                toast("復元しました");
            } catch {
                toast("復元に失敗しました");
            }
        }

        function resetAll() {
            localStorage.removeItem(LS_KEY);
            state.answers = Array(questions.length).fill(null);
            state.flagged = Array(questions.length).fill(false);
            idx = 0;
            submitted = false;
            locked = false;
            remainingSec = 40 * 60;
            elTimer.textContent = fmt(remainingSec);
            render();
            toast("リセットしました");
        }

        // ========= Submit / Review =========
        function doSubmit(auto = false) {
            submitted = true;
            const score = calcScore();
            const ac = answeredCount();

            scoreBadge.textContent = `得点: ${score} / ${questions.length}`;
            answeredBadge.textContent = `回答: ${ac} / ${questions.length}`;
            timeBadge.textContent = `残り時間: ${fmt(remainingSec)}`;

            if (!auto) dlg.showModal();
            render();
        }

        function gotoFirstWrong() {
            for (let i = 0; i < questions.length; i++) {
                const a = state.answers[i];
                if (a !== null && a !== questions[i].answer) { go(i); return; }
            }
            toast("不正解がありません（または未回答のみ）");
        }

        function gotoFirstFlagged() {
            for (let i = 0; i < questions.length; i++) {
                if (state.flagged[i]) { go(i); return; }
            }
            toast("旗の問題がありません");
        }

        function lockReview() {
            locked = true;
            toast("採点状態を固定しました（回答変更不可）");
            render();
        }

        // ========= Toast =========
        function toast(msg) {
            const d = document.createElement("div");
            d.textContent = msg;
            d.style.position = "fixed";
            d.style.left = "50%";
            d.style.bottom = "18px";
            d.style.transform = "translateX(-50%)";
            d.style.background = "rgba(0,0,0,.75)";
            d.style.border = "1px solid rgba(255,255,255,.14)";
            d.style.color = "white";
            d.style.padding = "10px 12px";
            d.style.borderRadius = "12px";
            d.style.boxShadow = "0 10px 30px rgba(0,0,0,.35)";
            d.style.zIndex = "9999";
            d.style.fontSize = "13px";
            document.body.appendChild(d);
            setTimeout(() => d.remove(), 1200);
        }

        // ========= Events =========
        prevBtn.addEventListener("click", prev);
        nextBtn.addEventListener("click", next);
        jumpFirst.addEventListener("click", () => go(0));
        jumpLast.addEventListener("click", () => go(questions.length - 1));

        toggleFlagBtn.addEventListener("click", toggleFlag);
        clearBtn.addEventListener("click", clearAnswer);
        saveBtn.addEventListener("click", save);
        loadBtn.addEventListener("click", load);
        resetBtn.addEventListener("click", resetAll);

        submitBtn.addEventListener("click", () => doSubmit(false));

        closeDlg.addEventListener("click", () => dlg.close());
        reviewWrong.addEventListener("click", () => { dlg.close(); gotoFirstWrong(); });
        reviewFlagged.addEventListener("click", () => { dlg.close(); gotoFirstFlagged(); });
        lockBtn.addEventListener("click", () => { lockReview(); dlg.close(); });

        // keyboard shortcuts
        window.addEventListener("keydown", (e) => {
            if (e.target && (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")) return;
            if (e.key === "ArrowRight") { next(); }
            if (e.key === "ArrowLeft") { prev(); }
            if (!locked) {
                if (e.key === "1") choose("ア");
                if (e.key === "2") choose("イ");
                if (e.key === "3") choose("ウ");
                if (e.key === "4") choose("エ");
            }
        });

        // ========= Init =========
        buildGrid();
        elTimer.textContent = fmt(remainingSec);
        render();
        startTimer();
    </script>
</body>

</html>