/**
 * 問題データ（科目B 模擬試験）
 * 試験区分: group（アルゴリズム・プログラミング / 情報セキュリティ）
 * 出題テーマ: theme（整列、探索、再帰など）
 * option format: { k: "ア", t: "...." }
 */

import { code1, code2, code3, code4, code5, code6, code7, code8, code9, code10, code11, code12 } from "./code.js";

export const questions = [
    // 1-10 整列（選択ソート）
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（選択ソート）",
        stem: "次の擬似言語は，配列 A の要素を昇順に並べ替える処理である。",
        code: code1,
        text: "外側ループ1回目終了後に確定している要素はどれか。",
        options: [
            { k: "ア", t: "7" },
            { k: "イ", t: "3" },
            { k: "ウ", t: "9" },
            { k: "エ", t: "4" },
        ],
        answer: "ウ",
        explain: "外側ループ1回目では探索範囲 A[1]～A[5] の最大値 9 が末尾に移動し確定する。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（選択ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code1,
        text: "外側ループ2回目終了後，確定している要素の個数はどれか。",
        options: [
            { k: "ア", t: "1" },
            { k: "イ", t: "2" },
            { k: "ウ", t: "3" },
            { k: "エ", t: "4" },
        ],
        answer: "イ",
        explain: "1回目で 9，2回目で 7 が末尾側に確定するため，確定要素は2個。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（選択ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code1,
        text: "外側ループ3回目（last=3）で行われる比較回数はどれか。",
        options: [
            { k: "ア", t: "0" },
            { k: "イ", t: "1" },
            { k: "ウ", t: "2" },
            { k: "エ", t: "3" },
        ],
        answer: "ウ",
        explain: "内側ループは i=2～last。last=3 なので i=2,3 の2回比較する。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（選択ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code1,
        text: "MAX の初期化が「MAX ← A[1]」である理由として最も適切なものはどれか。",
        options: [
            { k: "ア", t: "先頭要素が最大と仮定して探索を開始するため" },
            { k: "イ", t: "添字1が常に最大だから" },
            { k: "ウ", t: "A[0]が存在しないから" },
            { k: "エ", t: "交換回数を減らすため" },
        ],
        answer: "ア",
        explain: "最大値探索では暫定の最大値を1つ置いて更新していく。先頭要素を暫定最大として開始するのが自然。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（選択ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code1,
        text: "外側ループのある回で，配列の内容が変化しないのはどの場合か。",
        options: [
            { k: "ア", t: "MAX が更新されなかった場合" },
            { k: "イ", t: "MAX_POS = last の場合" },
            { k: "ウ", t: "MAX < A[last] の場合" },
            { k: "エ", t: "i が last に達しない場合" },
        ],
        answer: "イ",
        explain: "最大値がすでに A[last] にあると MAX_POS=last となり，同一要素同士の交換になるため配列は変化しない。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（選択ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code1,
        text: "内側ループで A[1] が比較されない理由として正しいものはどれか。",
        options: [
            { k: "ア", t: "すでに確定済みだから" },
            { k: "イ", t: "MAX の初期値として使われるから" },
            { k: "ウ", t: "for文が1始まりだから" },
            { k: "エ", t: "意味がないから" },
        ],
        answer: "イ",
        explain: "比較は i=2 から始まるため A[i] として A[1] は出てこないが，MAX の初期値として A[1] は利用される。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（選択ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code1,
        text: "全体の比較回数の合計として正しい式はどれか。",
        options: [
            { k: "ア", t: "(N−1)+(N−2)+…+2" },
            { k: "イ", t: "(N−1)+(N−2)+…+1" },
            { k: "ウ", t: "N(N−1)/2" },
            { k: "エ", t: "N²" },
        ],
        answer: "イ",
        explain: "各回の比較回数は last=Nで(N−1)，…，last=2で1回。last=2のときも i=2 to 2 が1回実行されるため，最後の「+1」が必要。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（選択ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code1,
        text: "この処理が安定ソートでない理由として正しいものはどれか。",
        options: [
            { k: "ア", t: "最大値を探索するから" },
            { k: "イ", t: "同じ値の相対順序が保持されないから" },
            { k: "ウ", t: "2重ループだから" },
            { k: "エ", t: "交換処理があるから" },
        ],
        answer: "イ",
        explain: "選択型の交換では，同値要素の相対順序が入れ替わる可能性があるため安定ではない。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（選択ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code1,
        text: "この処理とバブルソートの最大の違いはどれか。",
        options: [
            { k: "ア", t: "使用する変数" },
            { k: "イ", t: "比較対象の範囲" },
            { k: "ウ", t: "交換回数" },
            { k: "エ", t: "配列の長さ" },
        ],
        answer: "イ",
        explain: "バブルソートは隣接要素同士の比較を繰り返す。ここでは探索範囲全体から最大値を探して末尾へ移動する。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（選択ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code1,
        text: "この処理の計算量（オーダ）として最も適切なものはどれか。",
        options: [
            { k: "ア", t: "O(N)" },
            { k: "イ", t: "O(N log N)" },
            { k: "ウ", t: "O(N²)" },
            { k: "エ", t: "O(2ⁿ)" },
        ],
        answer: "ウ",
        explain: "比較回数は (N−1)+(N−2)+…+1 でおおむね N²/2 に比例するため O(N²)。"
    },

    // 11-19 整列（バブルソート）
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（バブルソート）",
        stem: "次の擬似言語は，配列 A の隣接要素を比較して必要に応じて交換する処理である。",
        code: code2,
        text: "この処理が1回実行された後，末尾に移動する可能性がある要素はどれか。",
        options: [
            { k: "ア", t: "4" },
            { k: "イ", t: "6" },
            { k: "ウ", t: "2" },
            { k: "エ", t: "1" },
        ],
        answer: "イ",
        explain: "隣接交換を左から右へ1回流すと，大きい値ほど右へ押し出され，最大値が末尾へ到達しやすい。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（バブルソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code2,
        text: "この処理を1回実行した後の配列として正しいものはどれか。",
        options: [
            { k: "ア", t: "[ 4, 2, 5, 1, 6 ]" },
            { k: "イ", t: "[ 4, 6, 2, 1, 5 ]" },
            { k: "ウ", t: "[ 4, 2, 6, 1, 5 ]" },
            { k: "エ", t: "[ 4, 6, 2, 5, 1 ]" },
        ],
        answer: "ア",
        explain: "手順： (4,6)交換なし→(6,2)交換→(6,5)交換→(6,1)交換。結果は [4,2,5,1,6]。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（バブルソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code2,
        text: "この処理を N−1 回繰り返すと完成するソートはどれか。",
        options: [
            { k: "ア", t: "選択ソート" },
            { k: "イ", t: "クイックソート" },
            { k: "ウ", t: "バブルソート" },
            { k: "エ", t: "マージソート" },
        ],
        answer: "ウ",
        explain: "隣接比較と交換を繰り返し，最大値が末尾へ「泡上がり」していくのがバブルソート。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（バブルソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code2,
        text: "while 条件が「i ≤ N」だった場合に起こる問題はどれか。",
        options: [
            { k: "ア", t: "無限ループ" },
            { k: "イ", t: "添字範囲外参照" },
            { k: "ウ", t: "比較回数不足" },
            { k: "エ", t: "交換が起きない" },
        ],
        answer: "イ",
        explain: "i=N でもループに入ると A[i+1]=A[N+1] を参照してしまい範囲外。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（バブルソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code2,
        text: "この処理が安定ソートである理由として正しいものはどれか。",
        options: [
            { k: "ア", t: "隣接要素のみを交換するから" },
            { k: "イ", t: "最大値を探索しないから" },
            { k: "ウ", t: "ループ回数が一定だから" },
            { k: "エ", t: "一時変数を使うから" },
        ],
        answer: "ア",
        explain: "通常のバブルソートは「>」で比較し，同値なら交換しないため，同じ値の相対順序が保たれやすい（安定）。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（バブルソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code2,
        text: "この処理1回あたりの比較回数はどれか。",
        options: [
            { k: "ア", t: "N" },
            { k: "イ", t: "N−1" },
            { k: "ウ", t: "N−2" },
            { k: "エ", t: "1" },
        ],
        answer: "イ",
        explain: "i=1～N−1 の各回で A[i] と A[i+1] を比較するため N−1 回。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（バブルソート）",
        stem: "上の擬似言語を N−1 回繰り返したときの性質を考える。",
        code: code2,
        text: "この処理の計算量として正しいものはどれか。",
        options: [
            { k: "ア", t: "O(N)" },
            { k: "イ", t: "O(N log N)" },
            { k: "ウ", t: "O(N²)" },
            { k: "エ", t: "O(log N)" },
        ],
        answer: "ウ",
        explain: "1回あたり O(N) を N−1 回繰り返すため O(N²)。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（バブルソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code2,
        text: "if 文の条件を「A[i] >= A[i+1]」に変更した場合の影響として正しいものはどれか。",
        options: [
            { k: "ア", t: "正しく整列しなくなる" },
            { k: "イ", t: "安定性が失われる" },
            { k: "ウ", t: "比較回数が増える" },
            { k: "エ", t: "処理が高速化する" },
        ],
        answer: "イ",
        explain: "同値でも交換してしまうため，同じ値の相対順序が入れ替わり得て安定性が失われる。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（バブルソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code2,
        text: "この処理で比較されない要素の組はどれか。",
        options: [
            { k: "ア", t: "A[1] と A[2]" },
            { k: "イ", t: "A[2] と A[3]" },
            { k: "ウ", t: "A[3] と A[4]" },
            { k: "エ", t: "A[1] と A[5]" },
        ],
        answer: "エ",
        explain: "比較は常に隣接要素（i と i+1）。A[1] と A[5] は隣接しないため比較されない。"
    },
    // 20 整列（比較）
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（比較）",
        stem: "問1〜10（最大値を末尾に確定）と，問11〜19（隣接比較）を比較する。",
        code: "",
        text: "両者の本質的な違いとして最も適切なものはどれか。",
        options: [
            { k: "ア", t: "使用する変数" },
            { k: "イ", t: "ソート対象" },
            { k: "ウ", t: "比較方法" },
            { k: "エ", t: "ループ構造" },
        ],
        answer: "ウ",
        explain: "前半は探索範囲全体から最大値を探す（全体比較型）。後半は隣接要素を比較する（隣接比較型）。"
    },

    // 21-25 探索（線形探索）
    {
        group: "アルゴリズム・プログラミング",
        theme: "探索（線形探索）",
        stem: "次の擬似言語は，配列 A から target の値を線形探索する処理である。",
        code: code3,
        text: "target=9 のとき，pos の最終値はどれか。",
        options: [
            { k: "ア", t: "1" },
            { k: "イ", t: "2" },
            { k: "ウ", t: "3" },
            { k: "エ", t: "4" },
        ],
        answer: "エ",
        explain: "A[1]=3, A[2]=7, A[3]=1, A[4]=9 で一致。pos=4 が代入される。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "探索（線形探索）",
        stem: "上の擬似言語に関する設問である。",
        code: code3,
        text: "target が配列に存在しない場合，pos の値はどれか。",
        options: [
            { k: "ア", t: "−1" },
            { k: "イ", t: "0" },
            { k: "ウ", t: "N" },
            { k: "エ", t: "N+1" },
        ],
        answer: "イ",
        explain: "見つからない場合，pos は初期値 0 のまま。ループ終了後も変更されない。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "探索（線形探索）",
        stem: "上の擬似言語に関する設問である。",
        code: code3,
        text: "最悪の場合の比較回数はどれか。",
        options: [
            { k: "ア", t: "1" },
            { k: "イ", t: "N−1" },
            { k: "ウ", t: "N" },
            { k: "エ", t: "N+1" },
        ],
        answer: "ウ",
        explain: "target が末尾にあるか存在しない場合，N 回比較する。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "探索（線形探索）",
        stem: "上の擬似言語に関する設問である。",
        code: code3,
        text: "この探索の計算量として正しいものはどれか。",
        options: [
            { k: "ア", t: "O(1)" },
            { k: "イ", t: "O(log N)" },
            { k: "ウ", t: "O(N)" },
            { k: "エ", t: "O(N²)" },
        ],
        answer: "ウ",
        explain: "線形探索は配列を順に調べるため O(N)。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "探索（線形探索）",
        stem: "上の擬似言語に関する設問である。",
        code: code3,
        text: "ループ条件を「i < N」にした場合の問題はどれか。",
        options: [
            { k: "ア", t: "先頭要素を調べない" },
            { k: "イ", t: "末尾要素を調べない" },
            { k: "ウ", t: "無限ループになる" },
            { k: "エ", t: "添字範囲外参照になる" },
        ],
        answer: "イ",
        explain: "i は 1 から N−1 までしか回らず，A[N] を比較しない。"
    },

    // 26-30 探索（二分探索）
    {
        group: "アルゴリズム・プログラミング",
        theme: "探索（二分探索）",
        stem: "次の擬似言語は，昇順ソート済み配列 A から target を二分探索する処理である。",
        code: code4,
        text: "target=7 のとき，最初に比較される A[mid] の値はどれか。",
        options: [
            { k: "ア", t: "3" },
            { k: "イ", t: "5" },
            { k: "ウ", t: "7" },
            { k: "エ", t: "9" },
        ],
        answer: "イ",
        explain: "low=1, high=6 で mid=(1+6)÷2=3。A[3]=5 が最初に比較される。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "探索（二分探索）",
        stem: "上の擬似言語に関する設問である。",
        code: code4,
        text: "target=7 が見つかったとき，pos の値はどれか。",
        options: [
            { k: "ア", t: "3" },
            { k: "イ", t: "4" },
            { k: "ウ", t: "5" },
            { k: "エ", t: "6" },
        ],
        answer: "イ",
        explain: "A[4]=7 なので pos=4 が代入される。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "探索（二分探索）",
        stem: "上の擬似言語に関する設問である。",
        code: code4,
        text: "二分探索が線形探索より有利な条件はどれか。",
        options: [
            { k: "ア", t: "配列が小さいとき" },
            { k: "イ", t: "配列がソート済みのとき" },
            { k: "ウ", t: "探索対象が先頭付近にあるとき" },
            { k: "エ", t: "探索対象が複数あるとき" },
        ],
        answer: "イ",
        explain: "二分探索はソート済み配列に対して O(log N) で探索できる。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "探索（二分探索）",
        stem: "上の擬似言語に関する設問である。",
        code: code4,
        text: "この探索の計算量として正しいものはどれか。",
        options: [
            { k: "ア", t: "O(1)" },
            { k: "イ", t: "O(log N)" },
            { k: "ウ", t: "O(N)" },
            { k: "エ", t: "O(N²)" },
        ],
        answer: "イ",
        explain: "毎回探索範囲を半分にするため O(log N)。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "探索（二分探索）",
        stem: "上の擬似言語に関する設問である。",
        code: code4,
        text: "target=8（配列に存在しない）のとき，ループ終了時のlowとhighの関係はどれか。",
        options: [
            { k: "ア", t: "low = high" },
            { k: "イ", t: "low > high" },
            { k: "ウ", t: "low = high + 1" },
            { k: "エ", t: "low < high" },
        ],
        answer: "イ",
        explain: "見つからない場合，範囲を狭めていき最終的に low > high で終了する。"
    },

    // 31-35 再帰
    {
        group: "アルゴリズム・プログラミング",
        theme: "再帰",
        stem: "次の擬似言語は，階乗を計算する再帰関数である。",
        code: code5,
        text: "FACT(3) の戻り値はどれか。",
        options: [
            { k: "ア", t: "1" },
            { k: "イ", t: "3" },
            { k: "ウ", t: "6" },
            { k: "エ", t: "9" },
        ],
        answer: "ウ",
        explain: "FACT(3)=3×FACT(2)=3×2×FACT(1)=3×2×1=6。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "再帰",
        stem: "上の擬似言語に関する設問である。",
        code: code5,
        text: "再帰の基底条件（終了条件）はどれか。",
        options: [
            { k: "ア", t: "n ≤ 0" },
            { k: "イ", t: "n ≤ 1" },
            { k: "ウ", t: "n = 2" },
            { k: "エ", t: "return 文" },
        ],
        answer: "イ",
        explain: "n ≤ 1 のとき 1 を返して再帰を終了する。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "再帰",
        stem: "上の擬似言語に関する設問である。",
        code: code5,
        text: "FACT(4) の計算で，FACT が呼び出される回数はどれか。",
        options: [
            { k: "ア", t: "3" },
            { k: "イ", t: "4" },
            { k: "ウ", t: "5" },
            { k: "エ", t: "6" },
        ],
        answer: "イ",
        explain: "FACT(4)→FACT(3)→FACT(2)→FACT(1) で 4 回呼び出される。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "再帰",
        stem: "上の擬似言語に関する設問である。",
        code: code5,
        text: "再帰をループに書き換えた場合の計算量はどれか。",
        options: [
            { k: "ア", t: "O(1)" },
            { k: "イ", t: "O(log N)" },
            { k: "ウ", t: "O(N)" },
            { k: "エ", t: "O(N²)" },
        ],
        answer: "ウ",
        explain: "階乗は n 回の掛け算で O(N)。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "再帰",
        stem: "上の擬似言語に関する設問である。",
        code: code5,
        text: "再帰の利点として適切なものはどれか。",
        options: [
            { k: "ア", t: "必ず高速になる" },
            { k: "イ", t: "メモリ使用量が少ない" },
            { k: "ウ", t: "問題を分割して記述しやすい" },
            { k: "エ", t: "無限ループにならない" },
        ],
        answer: "ウ",
        explain: "再帰は問題を小さな部分に分割して記述でき，コードが簡潔になる場合がある。"
    },

    // 36-40 データ構造（スタック）
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（スタック）",
        stem: "次の擬似言語は，配列を用いたスタックの実装である。",
        code: code6,
        text: "PUSH(10), PUSH(20), PUSH(30) の後，top の値はどれか。",
        options: [
            { k: "ア", t: "1" },
            { k: "イ", t: "2" },
            { k: "ウ", t: "3" },
            { k: "エ", t: "4" },
        ],
        answer: "ウ",
        explain: "PUSH を 3 回呼ぶと top は 3 になる。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（スタック）",
        stem: "上の擬似言語に関する設問である。",
        code: code6,
        text: "スタックの特徴として正しいものはどれか。",
        options: [
            { k: "ア", t: "先入れ先出し（FIFO）" },
            { k: "イ", t: "後入れ先出し（LIFO）" },
            { k: "ウ", t: "先入れ後出し" },
            { k: "エ", t: "任意の位置から取り出せる" },
        ],
        answer: "イ",
        explain: "スタックは LIFO（Last In, First Out）。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（スタック）",
        stem: "上の擬似言語に関する設問である。",
        code: code6,
        text: "空のスタックで POP を呼んだときの戻り値はどれか。",
        options: [
            { k: "ア", t: "0" },
            { k: "イ", t: "−1" },
            { k: "ウ", t: "未定義" },
            { k: "エ", t: "エラー" },
        ],
        answer: "イ",
        explain: "top=0 のとき −1 を返す実装になっている。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（スタック）",
        stem: "上の擬似言語に関する設問である。",
        code: code6,
        text: "PUSH(5), PUSH(8), POP(), PUSH(3) の後，S[1] と S[2] の値はどれか。",
        options: [
            { k: "ア", t: "S[1]=5, S[2]=3" },
            { k: "イ", t: "S[1]=5, S[2]=8" },
            { k: "ウ", t: "S[1]=8, S[2]=3" },
            { k: "エ", t: "S[1]=3, S[2]=5" },
        ],
        answer: "ア",
        explain: "PUSH(5)→S[1]=5, PUSH(8)→S[2]=8, POP()→8 取り出し top=1, PUSH(3)→S[2]=3。結果 S[1]=5, S[2]=3。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（スタック）",
        stem: "上の擬似言語に関する設問である。",
        code: code6,
        text: "スタックの典型的な用途として正しいものはどれか。",
        options: [
            { k: "ア", t: "CPU のプロセススケジューリング" },
            { k: "イ", t: "関数呼び出しの管理" },
            { k: "ウ", t: "ファイルの先頭読み出し" },
            { k: "エ", t: "データベースの検索" },
        ],
        answer: "イ",
        explain: "関数呼び出し時，戻りアドレスなどをスタックに積む。"
    },

    // 41-45 整列（挿入ソート）
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（挿入ソート）",
        stem: "次の擬似言語は，配列 A を挿入ソートで昇順に並べ替える処理である。",
        code: code7,
        text: "i=3 のループで x に代入される値はどれか。",
        options: [
            { k: "ア", t: "2" },
            { k: "イ", t: "5" },
            { k: "ウ", t: "8" },
            { k: "エ", t: "1" },
        ],
        answer: "ウ",
        explain: "i=2 で x=2，i=3 で x=A[3]=8 が代入される。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（挿入ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code7,
        text: "このソートの特徴として正しいものはどれか。",
        options: [
            { k: "ア", t: "安定ソートである" },
            { k: "イ", t: "非安定ソートである" },
            { k: "ウ", t: "選択ソートより比較回数が多い" },
            { k: "エ", t: "計算量は O(N log N)" },
        ],
        answer: "ア",
        explain: "挿入ソートは同値の相対順序を保つ安定ソート。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（挿入ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code7,
        text: "このソートの計算量として正しいものはどれか。",
        options: [
            { k: "ア", t: "O(N)" },
            { k: "イ", t: "O(N log N)" },
            { k: "ウ", t: "O(N²)" },
            { k: "エ", t: "O(log N)" },
        ],
        answer: "ウ",
        explain: "二重ループで最悪 O(N²)。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（挿入ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code7,
        text: "すでに昇順に並んでいる配列に対する計算量はどれか。",
        options: [
            { k: "ア", t: "O(1)" },
            { k: "イ", t: "O(N)" },
            { k: "ウ", t: "O(N²)" },
            { k: "エ", t: "O(N log N)" },
        ],
        answer: "イ",
        explain: "内側 while がほとんど実行されず，各要素は1回ずつ比較される。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "整列（挿入ソート）",
        stem: "上の擬似言語に関する設問である。",
        code: code7,
        text: "このソートとバブルソートの共通点はどれか。",
        options: [
            { k: "ア", t: "最大値を探して末尾へ移動する" },
            { k: "イ", t: "隣接要素を比較する" },
            { k: "ウ", t: "再帰を用いる" },
            { k: "エ", t: "非安定ソートである" },
        ],
        answer: "イ",
        explain: "どちらも隣接要素の比較・交換を基本とする。"
    },

    // 46-50 データ構造（キュー）
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（キュー）",
        stem: "次の擬似言語は，配列を用いたキューの実装である。",
        code: code8,
        text: "キューの特徴として正しいものはどれか。",
        options: [
            { k: "ア", t: "後入れ先出し（LIFO）" },
            { k: "イ", t: "先入れ先出し（FIFO）" },
            { k: "ウ", t: "任意の位置から取り出せる" },
            { k: "エ", t: "スタックと同様の動作" },
        ],
        answer: "イ",
        explain: "キューは FIFO（First In, First Out）。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（キュー）",
        stem: "上の擬似言語に関する設問である。",
        code: code8,
        text: "ENQUEUE(10), ENQUEUE(20), DEQUEUE(), ENQUEUE(30) の後，先頭に残る値はどれか。",
        options: [
            { k: "ア", t: "10" },
            { k: "イ", t: "20" },
            { k: "ウ", t: "30" },
            { k: "エ", t: "空" },
        ],
        answer: "イ",
        explain: "10,20 を入れて 10 を取り出すと，先頭は 20。続けて 30 を入れる。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（キュー）",
        stem: "上の擬似言語に関する設問である。",
        code: code8,
        text: "tail が head の1つ前に来た場合の意味はどれか。",
        options: [
            { k: "ア", t: "空のキュー" },
            { k: "イ", t: "満杯のキュー" },
            { k: "ウ", t: "要素が1つ" },
            { k: "エ", t: "エラー状態" },
        ],
        answer: "イ",
        explain: "リングバッファで tail が head の1つ前になると満杯。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（キュー）",
        stem: "上の擬似言語に関する設問である。",
        code: code8,
        text: "キューの典型的な用途として正しいものはどれか。",
        options: [
            { k: "ア", t: "関数呼び出しの管理" },
            { k: "イ", t: "処理対象の待ち行列" },
            { k: "ウ", t: "括弧の対応チェック" },
            { k: "エ", t: "深さ優先探索" },
        ],
        answer: "イ",
        explain: "ジョブキュー，印刷キューなど待ち行列に使われる。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（キュー）",
        stem: "上の擬似言語に関する設問である。",
        code: code8,
        text: "空のキューで DEQUEUE を呼んだときの戻り値はどれか。",
        options: [
            { k: "ア", t: "0" },
            { k: "イ", t: "−1" },
            { k: "ウ", t: "null" },
            { k: "エ", t: "未定義" },
        ],
        answer: "イ",
        explain: "head = tail のとき −1 を返す実装。"
    },

    // 51-55 文字列処理
    {
        group: "アルゴリズム・プログラミング",
        theme: "文字列処理",
        stem: "次の擬似言語は，テキスト T からパターン P を検索する単純照合である。",
        code: code9,
        text: "T=\"ABCDEFABCDEF\", P=\"CDE\" のとき，pos の値はどれか。",
        options: [
            { k: "ア", t: "1" },
            { k: "イ", t: "2" },
            { k: "ウ", t: "3" },
            { k: "エ", t: "4" },
        ],
        answer: "ウ",
        explain: "T の3文字目から \"CDE\" が一致。pos=3。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "文字列処理",
        stem: "上の擬似言語に関する設問である。",
        code: code9,
        text: "この検索の最悪計算量はどれか。",
        options: [
            { k: "ア", t: "O(M)" },
            { k: "イ", t: "O(N)" },
            { k: "ウ", t: "O(M × N)" },
            { k: "エ", t: "O(M + N)" },
        ],
        answer: "ウ",
        explain: "各位置で最大 N 文字比較し，位置は M−N+1 個。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "文字列処理",
        stem: "上の擬似言語に関する設問である。",
        code: code9,
        text: "P が T に存在しない場合，pos の値はどれか。",
        options: [
            { k: "ア", t: "−1" },
            { k: "イ", t: "0" },
            { k: "ウ", t: "M" },
            { k: "エ", t: "M+1" },
        ],
        answer: "イ",
        explain: "見つからない場合，pos は初期値 0 のまま。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "文字列処理",
        stem: "上の擬似言語に関する設問である。",
        code: code9,
        text: "SUBSTR(T, i, 1) の意味として正しいものはどれか。",
        options: [
            { k: "ア", t: "T の i 文字目を取得" },
            { k: "イ", t: "T の i 文字目から末尾まで" },
            { k: "ウ", t: "T の先頭から i 文字" },
            { k: "エ", t: "T の i 番目の部分文字列" },
        ],
        answer: "ア",
        explain: "SUBSTR(T, i, 1) は T の i 文字目から長さ 1 の部分文字列。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "文字列処理",
        stem: "上の擬似言語に関する設問である。",
        code: code9,
        text: "この検索より高速な文字列検索アルゴリズムはどれか。",
        options: [
            { k: "ア", t: "単純照合" },
            { k: "イ", t: "KMP 法" },
            { k: "ウ", t: "線形探索" },
            { k: "エ", t: "バブルソート" },
        ],
        answer: "イ",
        explain: "KMP 法は O(M+N) で動作する効率的な文字列検索。"
    },

    // 56-59 再帰（フィボナッチ）
    {
        group: "アルゴリズム・プログラミング",
        theme: "再帰（フィボナッチ）",
        stem: "次の擬似言語は，フィボナッチ数を計算する再帰関数である。",
        code: code10,
        text: "FIB(3) の戻り値はどれか。",
        options: [
            { k: "ア", t: "1" },
            { k: "イ", t: "2" },
            { k: "ウ", t: "3" },
            { k: "エ", t: "5" },
        ],
        answer: "イ",
        explain: "FIB(3)=FIB(2)+FIB(1)=FIB(1)+FIB(0)+1=1+0+1=2。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "再帰（フィボナッチ）",
        stem: "上の擬似言語に関する設問である。",
        code: code10,
        text: "FIB(5) の戻り値はどれか。",
        options: [
            { k: "ア", t: "3" },
            { k: "イ", t: "5" },
            { k: "ウ", t: "8" },
            { k: "エ", t: "13" },
        ],
        answer: "イ",
        explain: "FIB(5)=5。0,1,1,2,3,5 の5番目。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "再帰（フィボナッチ）",
        stem: "上の擬似言語に関する設問である。",
        code: code10,
        text: "この実装の問題点として正しいものはどれか。",
        options: [
            { k: "ア", t: "無限ループになる" },
            { k: "イ", t: "同じ計算を繰り返し行う" },
            { k: "ウ", t: "負の値を返す" },
            { k: "エ", t: "スタックオーバーフローしない" },
        ],
        answer: "イ",
        explain: "FIB(n) が FIB(n-1) と FIB(n-2) を呼び，同じ n に対し複数回計算される。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "再帰（フィボナッチ）",
        stem: "上の擬似言語に関する設問である。",
        code: code10,
        text: "FIB(n) の呼び出し回数はおよそどれに比例するか。",
        options: [
            { k: "ア", t: "n" },
            { k: "イ", t: "n²" },
            { k: "ウ", t: "2ⁿ" },
            { k: "エ", t: "log n" },
        ],
        answer: "ウ",
        explain: "各呼び出しが2つに分岐するため，指数関数的に増える。"
    },

    // 60-63 連結リスト
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（連結リスト）",
        stem: "次の擬似言語は，連結リストにノードを挿入する処理である。",
        code: code11,
        text: "p.next を new_node に代入する前に，new_node.next を設定する理由はどれか。",
        options: [
            { k: "ア", t: "メモリを節約するため" },
            { k: "イ", t: "p の次にあったノードへの参照を保持するため" },
            { k: "ウ", t: "先頭を更新するため" },
            { k: "エ", t: "エラーを防ぐため" },
        ],
        answer: "イ",
        explain: "new_node.next ← p.next で，元の次のノードへの参照を保持してから切り替える。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（連結リスト）",
        stem: "上の擬似言語に関する設問である。",
        code: code11,
        text: "この挿入の計算量はどれか。",
        options: [
            { k: "ア", t: "O(1)" },
            { k: "イ", t: "O(log N)" },
            { k: "ウ", t: "O(N)" },
            { k: "エ", t: "O(N²)" },
        ],
        answer: "ア",
        explain: "挿入位置 p が既に分かっていれば，定数時間で挿入可能。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（連結リスト）",
        stem: "上の擬似言語に関する設問である。",
        code: code11,
        text: "連結リストと配列の比較で正しいものはどれか。",
        options: [
            { k: "ア", t: "配列の方が挿入が速い" },
            { k: "イ", t: "連結リストは任意位置への挿入が容易" },
            { k: "ウ", t: "連結リストは添字アクセスが O(1)" },
            { k: "エ", t: "配列の方がメモリ効率が良い" },
        ],
        answer: "イ",
        explain: "連結リストは挿入・削除が容易。配列は一括シフトが必要。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（連結リスト）",
        stem: "上の擬似言語に関する設問である。",
        code: code11,
        text: "ALLOC(NODE) の役割はどれか。",
        options: [
            { k: "ア", t: "ノードを削除する" },
            { k: "イ", t: "ノード用のメモリを確保する" },
            { k: "ウ", t: "ノードを初期化する" },
            { k: "エ", t: "ノードを検索する" },
        ],
        answer: "イ",
        explain: "ALLOC はメモリ割り当て（allocate）を表す。"
    },

    // 64-67 木構造（二分探索木）
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（二分探索木）",
        stem: "次の擬似言語は，二分探索木から key を検索する処理である。",
        code: code12,
        text: "二分探索木の性質として正しいものはどれか。",
        options: [
            { k: "ア", t: "左部分木の値 > 根 > 右部分木の値" },
            { k: "イ", t: "左部分木の値 < 根 < 右部分木の値" },
            { k: "ウ", t: "すべてのノードの高さが等しい" },
            { k: "エ", t: "葉の数は常に2のべき乗" },
        ],
        answer: "イ",
        explain: "左子 < 親 < 右子 の関係が成り立つ。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（二分探索木）",
        stem: "上の擬似言語に関する設問である。",
        code: code12,
        text: "node = null になるのはどの場合か。",
        options: [
            { k: "ア", t: "key が見つかったとき" },
            { k: "イ", t: "子ノードが存在しないとき" },
            { k: "ウ", t: "木が空のとき，または存在しない経路に到達したとき" },
            { k: "エ", t: "ループの終了時" },
        ],
        answer: "ウ",
        explain: "空の木または探索範囲外（葉の次）で null に到達。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（二分探索木）",
        stem: "上の擬似言語に関する設問である。",
        code: code12,
        text: "平衡木の場合の探索の計算量はどれか。",
        options: [
            { k: "ア", t: "O(1)" },
            { k: "イ", t: "O(log N)" },
            { k: "ウ", t: "O(N)" },
            { k: "エ", t: "O(N²)" },
        ],
        answer: "イ",
        explain: "各段階で半分に絞り込むため O(log N)。"
    },
    {
        group: "アルゴリズム・プログラミング",
        theme: "データ構造（二分探索木）",
        stem: "上の擬似言語に関する設問である。",
        code: code12,
        text: "最悪の場合の探索の計算量はどれか。",
        options: [
            { k: "ア", t: "O(1)" },
            { k: "イ", t: "O(log N)" },
            { k: "ウ", t: "O(N)" },
            { k: "エ", t: "O(N²)" },
        ],
        answer: "ウ",
        explain: "一直線に伸びた木（リスト化）の場合，O(N)。"
    },
];
